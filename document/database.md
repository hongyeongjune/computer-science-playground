## 목차

<!-- 목차 -->
- [목차](#목차)
- [Primary Key 조건](#primary-key-조건)
- [무결성](#무결성)
- [InnerJoin vs OuterJoin](#innerjoin-vs-outerjoin)
- [SQL Injection](#sql-injection)
- [정규화](#정규화)
- [비정규화](#비정규화)
- [Index](#index)
- [트랜잭션](#트랜잭션)
- [트랜잭션 격리수준](#트랜잭션-격리수준)
- [SQL vs NoSQL](#sql-vs-nosql)
- [쿼리 실행 과정](#쿼리-실행-과정)
- [Partitioning and Sharding](#partitioning-and-sharding)
- [Replication](#replication)
- [Shared lock vs Exclusive lock](#shared-lock-vs-exclusive-lock)
<!-- /목차 -->

## Primary Key 조건
* PK 는 각 행을 고유하게 식별하는 역할
* 테이블 당 하나만 정의가 가능
* 지정된 컬럼에는 중복된 값이나 NULL 값이 입력될 수 없다.
* PK 로 지정한 칼럼이 여러 개 있을 때는 검색에 많이 사용되고, 간단하고 짧은 칼럼을 지정한다.
* 고유 Index 가 자동으로 생성된다.

## 무결성
* 무결성은 Database 에 저장된 데이터 값이 실제 데이터 값과 일치하는지에 대한 것을 말한다.
* 개체 무결성
    - 모든 테이블은 기본키를 가져야 하고, 기본키는 null 이나 중복이 될 수 없다.
* 참조 무결성
    - 외래키는 null 이 될 수 없고 참조 테이블의 기본키와 동일해야한다.
* 도메인 무결성
    - 도메인에 맞게 올바른 값을 가져야 한다.
* 서비스를 제공하는데 있어서 가장 중요한 것은 신뢰성이고 Database 에 올바른 값이 유지되어야만 신뢰성을 높일 수 있다.
* 따라서 무결성은 반드시 유지되어야 한다.

## InnerJoin vs OuterJoin
* InnerJoin 은 null 값을 포함하지 않고 조인을 하는 테이블의 교집합
    - 이너조인은 보통 그냥 Join 으로 사용
    - ansi join 은 SQL 을 사용하는 모든 데이터베이스에서 지원 하는 조인 형식 -> 이너 조인
* OuterJoin 은 null 값을 포함하고 조인을 하는 테이블의 합집합
    - Left OuterJoin
        - 왼쪽 테이블의 모든 데이터를 조회
    - Right OuterJoin
        - 오른쪽은 테이블의 모든 데이터를 조회
    - 반대 테이블은 null 로 출력
    - Full OuterJoin
        - 양쪽 테이블의 데이터를 모두 조회
        - mysql 지원 안함

## SQL Injection
* 사용자의 입력 값이 SQL 구문의 일부로 사용될 경우 조작된 SQL 구문이 데이터베이스에 그대로 전달되어서 비정상적인 Database 명령을 실행시키는 공격 기법
* 해결 방법
    - 일정 키워드를 정해놓고 키워드가 있는 SQL 문을 검증하는 방식
    - 미리 컴파일된 SQL 에 입력 데이터만 파라미터로 받아서 실행하는 PreparedStatement 를 사용하는 방식
* JPA 는 내부적으로 PreparedStatement 처럼 동작하여 Injection 으로 동작하는 것이 아닌 value 의 값이 들어가게 되어 안전한 상태임을 확인할 수 있다.
* PreparedStatement 에서 바인딩 데이터는 SQL 문법이 아닌 컴파일언어로 처리하기 때문에 문법적 의미를 가질 수 없으므로 바인딩 변수에 SQL Injection query 를 넣더라도 의미있는 쿼리로 동작하지 않는다.
* JPA 는 PreparedStatement 와 마찬가지로 파라미터를 바인딩해서 사용하기 때문에 SQL Injection 에 안전하다.

## 정규화
* 중복을 최소화하고 이상현상을 제ㅓ하기 위해 문제가 되는 릴레이션을 작게 분해하는 작업
* 릴레이션의 크기가 커지면 삽입이상, 삭제이상, 갱신이상 등의 문제가 발생할 수 있는데 정규화를 하면 이를 해결할 수 있다.
* 또한 릴레이션의 크기가 작아지므로 저장 공간을 최소화할 수 있다.
* 단점으로는, 릴레이션 간 연산이 많아져서 응답 시간이 느려질 수 있다.
* 이상 현상
    - ex. 테이블 구성 (학번, 이름, 강의코드, 과목명)
    - 삽입 이상 : 데이터 삽입을 위해 원하지 않는 값이 들어가게 됨
        - 100 홍영준 A123 데이터베이스
        - 100 홍영준 A124 네트워크
        - 아직 과목을 수강하지 않은 홍길동을 삽입할 때 원하지 않는 값인 강의코드, 과목명도 삽입해야됨
    - 갱신 이상 : 튜플의 일부만 갱신되어 데이터 불일치 현상이 발생
        - 100 홍영준 A123 데이터베이스
        - 100 홍영준 A124 네트워크
        - 첫 번째 로우의 이름을 홍길동으로 수정하면 데이터 불일치 현상 발생
    - 삭제 이상 : 상관없는 값들도 함께 삭제됨
        - 100 홍영준 A123 데이터베이스
        - 100 홍영준 A124 네트워크
        - 101 홍길동 A125 운영체제
        - 운영체제의 강의코드를 삭제하면 홍길동까지 같이 삭제됨
* 과정
    - 제 1 정규화
        - 모든 속성값을 원자값으로 한다.
    - 제 2 정규화
        - 제 1 정규화를 지키면서 부분함수종속을 없애는 것
        - 즉, 완전함수종속이 되게 하는 것
            - A 와 B 가 릴레이션 R 의 속성이고 A -> B 종속성이 성립할 때, B 가 A 의 속성 전체에 함수 종속하고 부분 집합 속성에 함수 종속하지 않을 경우
            - ex. 테이블 구성 PK(고객_ID, 상품_ID) (가격, 수량, 상품이름)
            - 고객_ID, 상품_ID -> 수량
            - 상품_ID -> 상품이름
            - 고객_ID, 수량, 상품_ID -> 가격
            - 이처럼 기본키를 제외한 다른 값이 다른 속성을 결정할 때 부분함수종속이라고하고 이걸 제거하는게 제2정규화의 목적이다.
    - 제 3 정규화
        - 제 2 정규화를 만족하면서 이행적 함수 종속을 제거
    - BCNF
        - 모든 결정자가 후보키 집합에 속해야한다.
        - 즉, 결정자이면서 후보키가 아니면 안된다.

## 비정규화
* 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위배하는 행위
* 장점
    - 조인 비용이 줄어들기 때문에 데이터 조회가 빠르고 쿼리가 간단해진다.
* 단점
    - 데이터 일관성이 깨지고 데이터 갱신이나 삽입 비용이 높아진다.
* 언제 사용하는가?
    - 자주 사용되는 테이블에 접근하는 프로세스의 수가 많고 항상 일정한 범위만 조회하는 경우
    - 테이블에 지나치게 조인을 많이 하게 되어서 데이터를 조회하는 것이 기술적으로 어려운 경우
* 비정규화를 과도하게하면 데이터의 무결성이 깨질 수 있으므로 유의해야한다.

## Index
* 관계형 데이터베이스의 조회 속도를 높이기 위한 기술
* 관계형 데이터베이스의 대용량 데이터를 Full Scan 하는 것이 아니라 인덱스가 적용된 특정 컬럼의 메타데이터를 저장한 파일을 읽어 범위(Range) 스캔을 한다.
* 인덱스는 B-Tree 를 자료구조로 사용한다.
    - B-Tree 는 균형 트리이고, 항상 정렬된 상태를 유지하기 때문에 조회의 속도가 매우 좋다.
    - 정렬상태를 유지시키기 위해 데이터 삽입마다 Rebuild 되기 때문에 삽입, 삭제, 갱신의 성능은 떨어진다.
* 다른 균형트리가 있음에도 B-Tree 사용하는 이유
    - 모든 자료구조와 그 어떤 알고리즘을 비교해도 탐색시간이 가장 빠른것은 HashTable 또는 HashMap 이다.
    - HashTable 은 해시 함수를 통해 나온 해시 값을 이용하여 저장된 메모리 공간에 한 번에 접근을 하기 때문에 O(1)이라는 시간 복잡도가 나온다. (해시 충돌 등 최악의 경우엔 O(N))
    - 하지만, Database 는 등호(=) 연산 뿐 아니라 부등호(<,>) 연산도 사용한다.
    - 즉, HashTable 에서 특정 값을 찾으려면 빠를 수 있지만, 특정 값보다 크거나 작은 값을 찾으려면 O(1)의 시간 복잡도를 보장할 수 업다.
    - RedBlack Tree 도 B-Tree 와 마찬가지로 균형트리이지만 사용할 수 없다.
    - RedBlack Tree 는 각 노드마다 무조건 하나의 데이터를 가진다.
    - 모든 데이터를 접근할 때 무조건 참조 포인터로 접근을 하게 된다.
    - 참조 포인터로 접근하는 것은 실제 메모리 상 순서대로 저장이 되었든 안 되었든 접근하려는 주소를 연산을 통해 직접 알아내야한다.
    - 이와 반대로 B-Tree 각 노드의 배열은 데이터들이 메모리 공간에 그대로 저장이 되어 있으므로 접근할 주소를 바로 알 수 있다.
    - 물론 B-Tree 도 자식 노드를 접근할 때는 참조 포인터로 접근을 하지만, 하나의 노드가 가지는 데이터의 개수가 많아질수록 포인터의 개수는 확연히 줄어든다.\
    - 그렇다면 그냥 배열로 해도되지않나? 라는 생각이 들 수 있다.
    - 하지만, 배열은 삽입, 삭제 시 shift 연산으로인해 O(N)의 시간복잡도가 발생한다.
    - B-Tree 는 삽입/삭제 시에도 항상 O(logN)의 시간복잡도를 가진다.
* 조회에 올인했다는 특징때문에 데이터 삽입, 갱신의 연산보다 데이터를 조회하는 경우에 훨씬 많이 사용합니다.

## 트랜잭션
* 데이터베이스의 작업 단위
* 특징
    - 원자성
        - All or Nothing 이라고 표현
        - 트랜잭션은 모두 성공적으로 완료되거나 모두 완료되지 않아야한다.
    - 일관성
        - 트랜잭션은 트랜잭션의 시작 전과 후의 상태(제약 조건)가 같아야한다.
        - 기본키 외래키 제약 같은 명시적인 무결성 제약 조건이 부합해야 한다. (ex. 계좌는 마이너스가 되면 안된다.)
        - 예를 들어, 계좌에 숫자형태가 들어가야하는데, 문자열이 들어가는 경우
    - 격리성
        - 트랜잭션이 어떠한 자원을 사용하고 있는 동안 다른 트랜잭션은 접근하지 못한다는 것
    - 지속성
        - 트랜잭션이 성공적으로 완료가 된 후에는 영구적으로 반영되어야 한다.

## 트랜잭션 격리수준
* 동시에 여러 트랜잭션이 처리될 때 어떤 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것
* 레벨이 높을수록 독립성이 증가하고 공유성이 감소
* 4단계의 격리수준
    - Read Uncommitted Level
        - 트랜잭션이 처리중이거나 커밋되지 않았더라도 다른 트랜잭션이 데이터를 읽을 수 있는 레벨
        - 이는 다른 트랜잭션이 읽을 때 잘못된 데이터를 읽을 수 있으므로 데이터의 일관성을 해치고 트랜잭션이 완료되지도 않았는데 다른 트랜잭션이 볼 수 있게 되는 Dirty Read 현상이 발생할 수 있다.
        - Dirty Read
            - 트랜잭션이 완료되지 않았는데 다른 트랜잭션에서 볼 수 있게 되는 현상
    - Read Committed Level
        - Dirty Read 현상은 발생하지 않는다.
        - 커밋을 한 데이터만 다른 트랜잭션이 읽을 수 있는 레벨
        - 오라클 Database 의 Default 값이다.
        - 실제 테이블의 값을 읽는 것은 아니고, undo 영역의 데이터를 읽는 것
        - 그 동안 실제 테이블은 값이 실제로 변경되고 있다.
        - 이때는 select 문을 두 번 날렸을 때 그 중간에 커밋이 발생해서 두 쿼리가 다른 결과가 반환되는 Non-Repeatable 문제가 발생할 수 있다.
        - 즉, 실제로 데이터가 HYJ, Back-end 라고 저장되어있고, A 트랜잭션에서 Back-end 를 Front-end 로 변경했을 때 B 트랜잭션은 Undo 영역에서 읽기 때문에 Back-end 라고 읽지만, 커밋이후에 다시 조회하면 Front-end 로 나오는 잘못된 현상
    - Repeatable Read Level
        - MySQL 의 Default 격리 수준이다.
        - 커밋이 완료될 때까지 다른 트랜잭션이 해당 데이터의 수정을 못하게 막는 것
        - 완료 전에 다른 트랜잭션에서 조회하면 Undo 영역에 데이터를 가져오는 것은 Read Committed 와 동일하나 Undo 영역에 데이터 버전들 중 어떤 버전을 가지고 오는가가 다름
        - 다른 트랜잭션의 커밋 여부에 상관없이 하나의 트랜잭션에서는 항상 같은 Undo 영역의 데이터를 반환한다.
        - 즉, Non-Repeatable 문제가 발생하지 않는다.
        - 하지만 하나의 트랜잭션에서 일정 범위의 데이터를 두 번 이상 읽을 때 똑같은 쿼리임에도 첫 번째 쿼리에 없던 레코드가 두 번째 쿼리에 나타나는 경우가 발생할 수 있다.
        - 데이터 삽입은 허용하기 때문에 발생하는 문제인데 이것을 Phantom Read 라고 한다.
    - Serializable Level
        - 이는 트랜잭션이 완료될 때까지 다른 트랜잭션은 해당 데이터의 수정 및 삽입을 허용하지 않는다.
        - 읽기 작업을 할때조차 Lock 을 건다.
        - 가장 엄격하고 확실하게 일관성을 보장하나 동시처리가 안되기 때문에 성능이 낮다.

## SQL vs NoSQL
* SQL
    - 데이터가 정해진 스키마에 따라 테이블에 저장되고, 데이터 관계를 통해 여러 테이블에 분산된다.
    - 즉, 구조화 언어
    - 명확하게 정의된 스키마, 데이터 무결성 보장
    - 관계는 각 테이블 중복없이 한번만 저장
    - 유연하지 않다. -> 데이터 스키마를 사전에 정의해야함
    - 관계를 맺고 있어서 조인문은 많은 쿼리가 만들어질 수 있다.
* NoSQL
    - 스키마도 관계도 없는 비구조화 언어
    - SQL 은 정해진 스키마를 따르지 않으면 데이터 추가가 불가능하지만 NoSQL 에서는 다른 구조의 데이터를 같은 컬렉션에 추가가 가능하다.
    - 스키마가 없어서 유연함 -> 언제든 저장된 데이터를 바꾸고 새로운 필드를 늘릴 수 있다.
    - 데이터는 애플리케이션이 필요한 형태로 저장하는 형식이기 때문에 데이터를 읽어오는 속도가 빠르다.
    - 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 함(SQL 은 중복이 없다.)


## 쿼리 실행 과정
* Connection
    - JDBC Api 와 같이 MySQL 서버 부분에 접근하기 위해 애플리케이션에서 사용하는 모듈
* MySQL - Server
    - Connection Pool 이나 옵티마이저 등
    - 클라이언트로 받은 쿼리를 분석하고 최적화 하여 실행계획을 만들고, 필요한 경우에는 메모리에 Cache 하는 기능
* MySQL - Server Storage Engine
    - InnoDB 와 같이 데이터를 저장하거나 추출하는 부분

## Partitioning and Sharding
* Database 의 규모가 커지면서 기존 Database 에 용량과 성능 문제 발생
* 테이블을 작은 단위로 나누는 것
    - 큰 테이블이나 인덱스를 관리하기 쉬운 파티션이라는 단위로 물리적 분할
    - 물리적으로 분할되어 있어도 접근하는 쪽에선 인지하지 못함
* 장점
    - 파티션 단위로 백업, 추가, 삭제, 변경할 수 있어서 관리적 측면에서 우수
    - 파티션 단위로 조회 및 DML 수행해서 성능적 측면에서 우수
* 단점
    - 테이블간 조인 비용 증가
    - 테이블과 인덱스를 별도로 파티셔닝 불가
    - 테이블과 인덱스를 같이 파티셔닝해야함
* 수평 파티셔닝
    - 하나의 테이블의 각 행을 다른 테이블에 분산시키는 것
    - Key 를 기반으로 여러 곳에 분산
        - 예를 들어, PK(Integer) 값을 키로 지정하고 0~50000 값은 A 테이블 50001 ~ 100000 은 B 테이블에 저장한다.
    - 장점
        - 데이터의 개수를 기준으로 나누어 파티셔닝 -> 따라서, index 개수도 작아져서 성능 향상
    - 단점
        - 데이터를 찾는 과정이 기존보다 복잡하기 때문에 복잡도 증
* 수직 파니셔닝
    - 모든 컬럼들 중 특정 컬럼들을 쪼개서 따로 저장하는 형태 -> 스키마를 나눠 데이터가 따라 옮겨가는 것
    - 즉, 하나의 엔티티를 2개 이상으로 분리
    - 장점
        - 자주 사용하는 컬럼을 분리하여 성능 향상 -> 한 테이블을 select 했을 때 모든 컬럼을 메모리에 올릴 필요가 없어 읽는 row 가 줄어든다. -> I/O 측면에서 성능상 이점
* 파티셔닝 기준
    - Partitioning Key 를 사용 한다.
    - 범위 분할
    - 목록 분할
    - 해시 분할
    - 합성 분할
* 샤딩
    - 파티셔닝이 하나의 데이터베이스 인스턴스에서 여러 테이블로 분할하는 것이라면, 샤딩은 하나의 큰 데이터 테이블을 여러 데이터베이스에 분할하는 것
    - 수평 파티셔닝과 동일하게 작동
    - 샤드 키 라는것으로 분할

## Replication
* 두 개 이상의 DBMS 시스템을 Master-Slave 로 나누어서 동일한 데이터를 저장
* 관계
    - Master 와 Slave 가 1:N
    - Master 는 데이터 조작(Insert, Update, Delete), Slave 는 조회(Select)
    - Master 와 Slave 동기화 필요 (MySQL 에서는 Binary log 라는 로그기반 복제 기법을 사용)

## Shared lock vs Exclusive lock
* 공유 잠금(Shared lock)
    - 읽기 잠금이라고 한다.
    - 어떤 트랜잭션에서 데이터를 읽고자 할 때 다른 Shared lock 은 허용하지만, Exclusive lock 은 불가하다.
    - 즉, 자원을 다른 사용자가 동시에 읽을 수 있게 하되, 변경은 불가능하게 한다.
    - 여러 개의 트랜잭션에 동시에 걸 수 있다.
    - 공유 잠금이 걸려있으면 배타 잠금을 걸 수 없다.
* 배타 잠금(Exclusive lock)
    - 쓰기 잠금이라고 한다.
    - 어떤 트랜잭션에서 데이터를 변경하고자 할 때 해당 트랜잭션이 완료될때 까지 해당 테이블 혹은 레코드를 다른 트랜잭션에서 읽거나 쓰지 못하게 한다.
    - 배타 잠금을 걸면 공유 잠금을 걸 수 없다.
    - 배타 잠금에 걸린 테이블, 레코드 등의 자원에 대해 다른 트랜잭션이 배타 잠금을 걸 수 없다.
    - 즉, 한 개의 트랜잭션만 걸 수 있다.
