## 목차

<!-- 목차 -->
-   [목차](#목차)
-   [운영체제 정의](#운영체제-정의)
-   [Process vs Thread](#process-vs-thread)
-   [동시성 문제](#동시성-문제)
-   [Process 간 데이터 공유 방법](#process-간-데이터-공유하는-방법)
-   [Multi Thread vs Multi Process](#multi-thread-vs-multi-process)
-   [Context Switching](#context-switching)
-   [동기화 (Synchronization)](#동기화-synchronization)
-   [기아 상태 (Starvation) 해결](#기아-상태-starvation-해결)
-   [Mutex vs Semaphore](#mutex-vs-semaphore)
-   [대기 방식 (Busy Waiting, Sleep)](#대기-방식-busy-waiting-sleep)
-   [Mutex, Semaphore 를 사용하면 동기화를 완전 보장하는가?](#mutex-semaphore-를-사용하면-동기화를-완전-보장하는가)
-   [교착 상태 (Deadlock)](#교착-상태-deadlock)
-   [CPU 스케줄링](#cpu-스케줄링)
-   [메모리 관리](#메모리-관리)
-   [Worst Fit 사용 이유](#worst-fit-사용-이유)
-   [내부 단편화와 외부 단편화](#내부-단편화와-외부-단편화)
-   [페이징 (Paging) 기법](#페이징-paging-기법)
-   [세그멘테이션 (Segmentation) 기법](#세그멘테이션-segmentation-기법)
-   [가상 메모리](#가상-메모리)
-   [페이지 폴트](#페이지-폴트)
-   [페이지 교체 알고리즘](#페이지-교체-알고리즘)
-   [Swapping](#swapping)
<!-- /목차 -->

## 운영체제 정의
* 프로세스, 자원 등을 효율적으로 관리하기 위한 SoftWare
* 컴퓨터 HardWare 바로 윗단에 설치되는 SoftWare
* SoftWare 가 컴퓨터 시스템에 수행되기 위해서는 메모리에 적재 되어야 한다.
* 운영체제도 하나의 SoftWare 로써 전원이 켜짐과 동시에 메모리에 적재된다.
* 운영체제처럼 규모가 큰 프로그램이 모두 메모리에 올라간다면 한정된 메모리 공간의 낭비가 심하다.
* 즉, 운영체제 중 항상 필요한 부분만 메모리에 적재되고, 그렇지 않은 부분은 필요할 때 메모리에 적재된다.
* 이때 메모리에 상주하는 운영체제의 부분을 커널(Kernel)이라 부르며 이를 좁은 의미의 운영체제라고 한다.
* 즉, 커널은 메모리에 상주하는 부분으로써 운영체제의 핵심적인 부분을 뜻한다.
* 또한, 커널에서 입출력 작업을 진행한다.

## Process vs Thread
* Process
    - 운영체제로부터 시스템 자원을 할당받는 작업의 단위
    - 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
    - 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
    - 한 프로세스가 다른 프로세스에 접근하려면 프로세스간 통신(IPC, inter-process communication)을 사용해야 한다.
    - ex. 유튜브 동영상을 재생하면 이건 하나의 프로세스
    - ex. Code, Data, Stack, Heap 구조로 되어있는 독립된 메모리 영역
      ![images](https://gmlwjd9405.github.io/images/os-process-and-thread/process.png)
    - code
        - 작성한 코드
        - read only 영역
    - data
        - static 변수, 배열 등
        - 프로그램이 시작될 때 만들어지고, 종료되면 사라진다.
    - heap
        - 필요에 의해 동적으로 메모리를 할당 하고자 할 때 위치하는 영역
        - 메모리 주소 값에 의해서만 참조되고 사용되는 영역
        - 자바는 new 연산자를 사용해 생성한 영역
    - stack
        - 임시 메모리 영역
        - 지역 변수, 파라미터, 리턴 값 등
        - 함수 호출 시 사용되고 함수 종료 시 사라진다.
* Thread
    - 프로세스내에서 실행되는 여러 흐름의 단위
    - 스레드는 프로세스의 영역 중에서 Stack 만 따로 할당받고 Code, Data, Heap 영역은 공유한다.
    - 스레드는 한 프로세스 내에서 동작하는 여러 실행의 흐름으로 프로세스 내의 주소나 공간이나 자원들(힙 공간 등)을 공유한다.
    - 같은 프로세스내의 스레드들은 힙 공간을 공유하지만, 프로세스는 다른 프로세스의 메모리에 접근할 수 없다.
      ![images](https://gmlwjd9405.github.io/images/os-process-and-thread/thread.png)
* 프로세스와 스레드의 차이에 대해서 설명하시오.
    - 프로세스는 실행중인 프로그램이고, 스레드는 프로세스 내에서 실행되는 흐름의 단위입니다.
    - 프로세스 CPU 와 메모리를 각각 독립적으로 받아서 사용하지만, 스레드는 프로세스 내에서 CPU 와 메모리를 공유하면서 실행합니다.

## 동시성 문제
* 동시성 문제는 어떤 문제인가?
    - 하나의 프로세스 안에서 여러 개의 스레드를 사용하는 경우가 많다.
    - 여러개의 스레드를 사용하면 동시에 공유 자원에 접근할 때 발생
    - synchronized 키워드 사용 -> 하나의 스레드만 접근할 수 있으며 다른 스레드는 먼저 진입한 스레드가 나갈때 까지 기다려야함

## Process 간 데이터 공유하는 방법
* 공유파일 사용
    - 가장 Legacy 한 방법
    - 송신할 프로세스가 파일에 공유할 데이터를 쓰고, 수신할 프로세스는 파일을 읽는 방법
* DataBase 사용
    - 공유할 데이터를 DataBase 에 저장하게되면 여러 프로세스는 공유할 데이터에 접근이 가능할 수 있다.
* IPC(Inter-Process Communication) 사용
    - 프로세스 간 통신을 할 수 있도록 운영체제가 제공하는 방법
    - 커널이란?
        - 운영체제도 소프트웨어이기 때문에 메모리에 올라가야된다.
        - 하지만, 메모리 공간 제약으로 운영체제 중 항상 필요한 부분만 메모리에 올려놓고, 그렇지 않은 부분은 필요할 때 메모리에 올린다.
        - 이 때 메모리에 상주하는 ㅇ영역을 커널이라고 한다.
    - 대표적인 예
        - 메세지 교환(Message Passing) 방식
            - 커널을 사용하여 데이터를 공유하는 기법
            - 메세지 큐를 사용하여 송신 프로세스는 enqueue 수신 프로세스는 dequeue 하며 상호간 통신
            - 커널을 사용하여 데이터를 공유하기 때문에 해당 방식은 동기화 처리가 필요 없지만, 공유 메모리 방식보다는 느리다는 단점이 있다.
        - 공유 메모리(Shared Memory) 방식
            - 특정 공유하는 메모리를 만들어 여러 프로세스가 통신하는 기법
            - 프로세스는 자신이 할당받은 메모리 외의 메모리를 참조하지 못하지만, 공유 메모리는 여러 프로세스가 접근할 수 있다.
            - 프로세스가 직접 메모리에 접근하기 때문에 속도는 빠르지만, 직접 접근하기 때문에 동기화 문제가 발생할 수 있어 프로세스 단에서 동기화를 해줘야하는 단점이있다.

## Multi Thread vs Multi Process
* Multi Thread
    - 스레드는 Context-Switching 비용이 적고 빠르기 때문에 자원의 효율성이 높다.
    - 스레드는 프로세스 내의 메모리 영역 중 스택을 제외한 영역을 공유한다.
    - 즉, global(전역), static(정적) 등 영역이 존재해 비교적 데이터를 공유하기 쉽다.
    - 멀티 스레드 방식의 프로그램에서는 하나의 스레드가 자신이 사용하던 데이터 공간을 망가뜨리면, 하나의 데이터 공간을 공유하는 모든 스레드를 작동불능 상태로 만드는 단점이있다.
    - 즉, 동기화 문제와 하나의 스레드 장애로 전체 스레드가 종료될 위험이 있다.
* Multi Process
    - 프로세스는 운영체제에게, 스레드는 프로세스에게 자원을 할당받기 때문에 크기가 큰 데이터를 처리해야하는 경우 스레드보다 프로세스를 사용하면 더 빠르게 처리할 수 있다.
    - 프로세스는 하나의 프로세스가 죽더라도 다른 프로세스에게 영향을 주지 않아 안정성이 높지만, 많은 메모리 공간과 CPU 를 차지하기 때문에 성능이 좋지 않다.
* 결론 : 상황에 따라 다르지만 보편적으로 Multi Thread 를 사용하는 것이 더 좋다.

## Context Switching
* 멀티 프로세스 환경에서 CPU 가 어떤 하나의 프로세스를 실행하고 있는 상태에 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야할 때 기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장하고 CPU 가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)을 교체하는 작업

## 동기화 (Synchronization)
* 프로세스 또는 스레드 간 공유 메모리를 사용할 때, 동일한 자원을 동시에 사용하며 발생하는 문제를 해결하는 것
* 즉, 여러 프로세스 또는 스레드가 공유된 자원에 접근할 때 수행시점을 조절하는 것이다.
* 임계 구역(Critical Section)
    - 프로세스 또는 스레드가 공유 메모리에 접근할 때 문제가 발생하지 않도록 한번에 하나의 프로세스 또는 스레드만 이용하게끔 보장해주는 영역
* 임계 구역(Critical Section)의 조건
    - Mutual Exclusion(상호 배제) : 임계 구역은 하나의 프로세스 또는 스레드만 사용할 수 있어야 한다.
    - Progress(진행) : 임계 구역에 들어갈 프로세스 또는 스레드는 순서를 가지고 있어야 한다.
    - Bounded Waiting(한정 대기)
        - 임계 구역에 접근할 프로세스 또는 스레드는 일정한(한정된) 시간만 기다려야한다.
        - 즉, 우선순위가 높은 프로세스 또는 스레드가 계속해서 들어오면 비교적 낮은 우선 순위를 가진 프로세스 또는 스레드는 계속 기다리는 상태, 기아 상태(Starvation)이 존재하면 안된다.

## 기아 상태 (Starvation) 해결
* 프로세스 또는 스레드의 우선 순위를 수시로 변경해서, 높은 우선 순위를 받을 기회를 준다.
* 기다린 시간에 비례해서 일정 시간이 지나면 우선 순위를 높여주는 Aging 기법을 사용한다.
* 우선 순위가 아닌, 요청 순서대로 처리하는 FIFO 기반 요청 큐를 사용한다.

## Mutex vs Semaphore
* 동기화를 위해 공유 메모리에 접근을 제한하는 방법
* Mutex
    - Semaphore 의 방식 중 하나 -> 상호 배제 기술
    - 공유 자원에 접근할 떄 카운트 변수(Lock)가 0과 1인 이진 세마포어
    - 즉, 오직 하나의 프로세스 또는 스레드만이 동일한 시점에 뮤텍스를 얻어 임계 영역에 들어올 수 있다.
    - 오직, 이 프로세스 또는 스레드만이 임계 영역에서 나갈 때 뮤텍스를 해제할 수 있다.
    - 즉, 뮤텍스가 1개의 Lock(카운트 변수)만을 갖는 Locking Mechanism 이다.
* Semaphore
    - 현재 공유자원에 접근할 수 있는 쓰레드, 프로세스의 수를 나타내는 값을 두어 상호배제를 달성하는 기법
    - 동기화를 위해 wait 와 signal 이라는 2개의 연산을 사용한다.
    - signal 을 호출하면 세마포어의 카운트를 1늘리고, wait 를 호출하면 세마포어의 카운트를 1줄이고, 세마포어의 카운트가 0보다 작거나 같아지는 경우 Lock 이 실행된다.
    - 즉, 뮤텍스와 다르게 1이상의 카운트 변수를 가지고, Signaling Mechanism 이다.

## 대기 방식 (Busy Waiting, Sleep)
* 동기화를 위해서 대기하는 경우 대표적으로 2가지 방식이 있다.
    - Busy Waiting
    - Sleep
* Busy Waiting
    - 어떤 조건을 만족하지 못하는 경우에, 그 조건을 만족할 때까지 다른 작업을 수행하지 않고 기다리는 경우를 의미
    - 즉, 임계 영역에 들어가기 전까지 무한 반복문을 돌리는 작업을 하여 CPU 를 낭비하는 단점이 있다.
    - 예시 : spin lock
* Sleep
    - 어떤 조건을 만족하지 못하는 경우에, 프로세스 또는 스레드를 Sleep 상태로 만들고, 이후에 깨우는 방식
    - Busy Waiting 과 다르게 CPU 점유를 하지 않고 조건을 만족할 때까지 잠들어서 CPU 자원 효율이 좋다.
    - Sleep 상태에서는 Queue 에 넣어 관리하고 접근 가능한 시점에 Interrupt 로 프로세스 또는 스레드를 깨워 사용하는 방법
    - Context Switching 의 부담을 줄이기 위해 Busy Waiting 을 사용하기도 한다.

## Mutex, Semaphore 를 사용하면 동기화를 완전 보장하는가?
* 완전하게 보장하지는 못한다.
* 스레드 A, B가 있고, 각각 A Critical Section 과 B Critical Section 에 접근한다고 가정하자.
* A Section 에서 B Section 을 참조, B Section 에서 A Section 을 참조하고 있다면,
* A 스레드, B 스레드는 각각 Critical Section 에 대한 Lock 을 획득하고, 작업 도중 서로의 섹션에 접근하기 위해 Lock 을 기다리고 있는 교착 상태(Deadlock)이 발생할 수 있다.

## 교착 상태 (Deadlock)
* 프로세스 또는 스레드가 하나 이상의 자원을 가지고 있는 상태에서, 서로 상대방의 자원을 요구하며 무한정으로 상대의 자원이 반환될때까지 기다리고 있는 문제
* 발생 조건
    - 상호 배제(Mutual Exclusion)
        - 한 번에 한 프로세스만 자원을 사용할 수 있어야 한다.
        - 즉, 사용중인 자원을 다른 프로세스가 요청하려면 요청한 자원이 다 사용되고 난 후 해제될때까지 기다려야한다.
    - 점유와 대기(Hold and Wait)
        - 프로세스는 자원을 점유한 동시에 대기해야한다.
        - 즉, 자신이 하나 이상의 자원을 가지고 다른 프로세스 또는 스레드에게 자원을 요구하며 기다리고 있는 상황이다.
    - 비 선점(Non Preemptive)
        - 자원을 선점할 수 없는 조건으로 누군가가 자원을 가지고 있을 때 빼앗을 수 없다.
        - 즉, 다른 프로세스 또는 스레드의 자원을 뺏을 수 없어 요구하고 기다리고 있어야 한다.
    - 순환(환형) 대기(Circle wait)
        - 프로세스 또는 스레드가 여러개 있을 때 자원의 점유와 요청의 관게가 순환되고 있는 상태
        - 즉, 프로세스 또는 스레드는 원형을 이루며 자원을 요구하고 있는 상태
* 4가지 조건 중 하나를 제거하거나 운영체제가 자원을 할당할 때 교착상태가 발생하는 조건인지 확인하고 주는 방식으로 해결할 수 있다.

## CPU 스케줄링
* 한정적인 CPU 자원을 프로세스가 공평하게 사용할 수 있도록 하는 알고리즘
* FCFS(First Come First Served)
    - 들어온 순서대로 CPU 자원을 점유하는 방식
    - 비선점형이기 때문에 점유하고 있는 프로세스의 작업 시간이 길다면 다음 프로세스는 계속 기다려야하는 문제가 발생할 수 있음
* SJF(Shortest Job First)
    - 짧은 작업이 이루어지는 프로세스를 먼저 처리하는 방법
    - 긴 작업시간을 가지는 프로세스는 도태되는 기아 현상이 발생할 수 있다. -> 해결 방법 : 에이징 기법
* Priority
    - 프로세스에 우선순위를 부여해서 높은 순으로 처리하는 방법
    - 우선순위가 낮은 프로세스는 기아 현상이 발생할 수 있다. -> 해결 방법 : 에이징 기법
* Round Robin
    - 일정한 Time Slice 만큼 프로세스가 공평하게 처리되는 방법
    - 앞의 SJF 와 Priority 의 기아 현상 문제가 발생하지 않으며 각 프로세스가 공평하게 처리되는 장점이 있다.
    - 하지만, Time Slice 가 너무 길어지면 FCFS 와 다를 것이 없고, 너무 작을 경우 Context Switching 이 많이 발생해 오버헤드가 발생할 수 있다.
* Multi-Level Queue
    - 프로세스가 대기하는 큐를 하나가 아닌 여러 큐로 두고, 각 큐마다 다른 스케줄링 기법을 사용하는 알고리즘
* Multi-Level FeedBack Queue
    - Multi-Level Queue 의 변형으로 각 큐의 프로세스는 다른 큐로 넘어갈 수 있는 스케줄링 기법

## 메모리 관리
* CPU 가 프로세스를 메인 메모리에 로드할 때 어디에 어떻게 로드할지 대한 방법

## 메모리 로드 방법
* 메모리를 어떻게 로드하는지에 대한 알고리즘
* First Fit
    - 메모리에 프로세스를 로드하기 위해 가장 처음 마주하는 빈 메모리에 로드하는 방법
* Best Fit
    - 가장 사이즈가 비슷한 Hole 에 로드하는 방법
* Worst Fit
    - 가장 큰 사이즈의 Hole 에 저장하는 방식

## Worst Fit 사용 이유
* 남는 공간에 다른 프로세스 및 다른 데이터를 배치할 수 있기 때문

## 내부 단편화와 외부 단편화
* 내부 단편화 : 어떤 프로세스가 필요한 양보다 더 큰 메모리를 할당받아 메모리 공간이 낭비되는 현상
* 외부 단편화 : 총 메모리 공간은 충분하지만 그 공간이 자잘자잘하게 퍼져있어 할당이 불가능

## 페이징 (Paging) 기법
* 외부 단편화를 해결하기 위한 방법
* 페이지라는 일정한 블럭에 나누어 저장하는 기법
* 즉, 페이지로 나누어진 각 프로세스는 페이지 테이블을 사용하여 논리적인 프로세스 순서를 보장하고 있다.
* 프로세스는 모두 같은 크기인 페이지라는 단위로 나뉘기 때문에 외부 단편화 문제는 발생하지 않지만, 내부 단편화는 발생하는 단점이 있다.

## 세그멘테이션 (Segmentation) 기법
* 내부 단편화를 해결하기 위한 방법
* 프로세스를 페이지 단위가 아닌, 논리적인 단위로 잘라 저장하는 방식
* 즉, 프로세스를 서로 다른 크기(가변적인)의 세그멘테이션으로 나누어서 메로리를 할당하는 방법
* 논리적인 단위로 나눴기 때문에 내부 단편화가 발생하진 않지만, 외부 단편화는 일어나는 단점이 있다.

## 가상 메모리
* 보조기억장치의 일부를 주기억장치처럼 사용하는 방식
* 한정적인 메모리 자원을 효율적으로 사용하기 위해 프로세스의 일부만 로드하고, 현재 요구되지 않는 블럭들은 가상 메모리에 저장하여 관리된다.
* 프로세스가 실행되며 현재 주기억장치에 로드되지 않은 페이지를 접근하려할 때, 페이지 폴트 발생
* 가상 메모리에 저장되어 있는 페이지를 주기억장치의 페이지와 교체하는 작업이 이루어진다.

## 페이지 폴트
* 메모리에 적재된 페이지 중에 사용 페이지가 없을 때

## 페이지 교체 알고리즘
* FIFO (First In First Out)
    - 메모리에 올라간 가장 오래된 페이지를 교체
* OPT (Optimal Page Replacement, 최적 페이지 교체)
    - 앞으로 가장 오랫동안 사용하지 않은 페이지 교체
    - 최적의 알고리즘이지만 프로세스가 앞으로 사용해야 할 페이지를 미리 알아야 하기 때문에 사실상 구현이 불가능하다.
* LRU (Least Recently Used)
    - 가장 대표적으로 알고 있다.
    - 가장 오랫동안 접근하지 않은 페이지와 교체하는 방식
    - 최적 알고리즘과 최대한 비슷하게 구현한 방식으로 구현이 가능하다.
* Count-Based
    - 각 페이지가 현재 참조된 횟수를 카운팅하는 방식
    - 대표적으로 2개 있다.
        - LFU (Least Frequently Used)
            - 참조 횟수가 가장 적은 것을 교체 -> 같은 참조 횟수가 여러개면 LRU 적용
        - MFU (Most Frequently Used)
            - 참조 횟수가 가장 많은 것을 교체 -> 참조 횟수가 가장 적은게 최근에 사용된거라는 판단하에 적용되는 것

## Swapping
* 프로세스는 실행되기 위해서 메인 메모리(주기억장치)에 로드되어야한다.
* 프로세스가 실행되려고 하는데 메인 메모리가 가득 찼다면,
* 사용중인 프로세스를 보조기억장치로 보내고,(Swap out)
* 보조기억장치에 있는 프로세스를 메인 메모리에 적재한다.(Swap In)
