## Redis
* Key-value 형태로 데이터를 저장하는 NoSQL 의 한 종류
* 인메모리 방식이라는 특징을 가지고 있어서 캐시 역할로 많이 사용한다.
* Redis 는 왜 싱글 스레드를 사용하는가?
    - Redis 의 병목 현상은 대부분 CPU 가 아닌 메모리 대역폭에서 발생한다.
        - 메모리 대역폭은 1초에 전송할 수 있는 데이터의 양
        - 여러 인스턴스가 메모리 대역폭을 나누어 사용하므로 병목 현상이 발생할 수 있다.
    - 동시성을 보장
        - 이벤트 루프 패턴을 통해 동시성을 구현하였고 Context Switching 비용이 없어서 자원을 절약함
* 사용 이유
    - 비즈니스 로직이 복잡하거나 항상 같은 결과를 내려주는 요청에 대해 응답 속도를 높이기 위해 캐시 역할로 사용
    - 프로젝트
        - Medna App 의 모든 차를 조회할 때 매번 같은 결과를 내려주기 때문에 사용
        - 제품 추천 알고리즘이 비즈니스 로직이 복잡하여 캐싱처리를 위해 사용
* 장점
    - Key-Value 형태로 되어있어서 저장 및 조회가 간편
    - Value 에 String, Set 등 여러 자료구조가 들어갈 수 있어서 다양한 방식으로 저장 가능
    - 데이터가 날라가도 복구할 수 있다. -> 스냅샷 기능을 사용하여 메모리의 내용을 *.rdb 파일로 저장하여 해당 시점으로 복구하는 방식과 Writer, Update Event 를 로그에 남겨서 이를 기반으로 복구하는 AOF 방식 두가지가 있다.
* 단점
    - 인메모리 방식이어서 컴퓨터가 종료되면 사라지니 유지가 필요한 데이터는 백업을 해주어야함
    - 세윤이형 스토리
        - Redis expire time 을 되게 길게 설정해주었는데, 생각보다 데이터가 엄청 많이 쌓여서 서버가 터졌던 경험
        - 즉, 만료 시간을 길게 해서 데이터가 많이 쌓이면 서버가 터짐
* vs Memcached
    - Redis 는 여러 자료구조를 지원하고 특정 시점에 스냅샷을 찍어 디스크에 저장해놓고 장애 발생 시 백업을 할 수 있다.
    - 다만 Redis 는 싱글 스레드기 때문에 1번에 1개의 요청만 처리할 수 있다.
    - 즉, Keys 같은 명령어를 사용하게 되면 속도가 느려진다.
        - Keys 명령어는 모든 키의 내용을 출력하는 명령어인데, 키가 많으면 키를 출력하는데 소요 시간이 길어질 수 있다.
        - Redis 는 싱글 스레드이기 때문에 이 작업을 하면 다른 작업을 못하므로 성능 상 큰 문제가 발생할 수 있다.
        - 해결 방법으로 scan 명령어를 사용할 수 있는데, scan 은 count 값을 정하여 count 만큼 읽어온다.
        - 예를들어, count 값을 10으로 하고 1000개의 키를 조회한다고 가정하면, 1000번에 나눠서 조회를 한다.
        - 키를 조회하는 총 시간은 오래걸릴 수 있지만, 사이사이에 다른 레디스 요청이 들어오면 그 요청을 처리할 수 있게 된다.
    - Memcached 는 멀티스레드를 지원하기 때문에 더 많은 작업처리를 할 수 있다.
    - 대신 Redis 처럼 데이터 타입과 API 가 다양하지 않다.
* Redis Transaction
    - 구성
        - MULTI
            - 트랜잭션 시작을 의미
            - 트랜잭션을 시작하면 Redis 는 이후 커맨드를 바로 실행하지 않고, 큐에 보관한다.
        - EXEC
            - 큐에 쌓여있던 명령어를 일괄적으로 실행한다.
        - DISCARD
            - 트랜잭션 큐에 쌓여있던 명령어가 지워지고 트랜잭션이 종료된다.
        - WATCH
            - 외부에서 선언한 키는 트랜잭션 외부에서 변경이 감지되면, 해당 키는 트랜잭션 내부에서 변경을 허용하지 않는다.
        - UNWATCH
            - WATCH Key 는 exec 명령어가 실행되면 즉시 UNWATCH 상태로 변경됨
            - 직접 UNWATCH 를 선언할 경우 WATCH 가 선언된 모든 키를 반환한다.
            - 각 키 별로 UNWATCH 를 직접 선언할 수 없다.
    - 트랜잭션 중 두 가지의 오류
        - 'EXEC' 명령어를 실행하기 이전 큐에 적재하는 도중 실패하는 경우
            - 어떤 경우?
                - 명령어가 문법적으로 잘못된 경우 ex. 존재하지 않는 명령어 사용
                - 메모리가 부족한 경우
            - Redis 2.6.5 이후 부터는 Server 에서 명령이 누적되는 동안 오류가 있음을 기억 -> EXEC 실행 시 트랜잭션 거부 오류 반환하고 자동으로 DISCARD 명령 처리
            - Redis 2.6.5 이전에는 트랜잭션 내의 명령들 중 성공적으로 처리할 수 있는 일부분의 명령만 실행됨
        - 'EXEC' 명령어를 실행한 이후 실패하는 경우
            - 어떤 경우?
                - 잘못된 명령어 사용 ex. String 값에 List 에서만 실행할 수 있는 명령을 호출
            - 특별한 방법으로 처리되지는 않는다.
            - 즉, 트랜잭션 중에 일부 명령이 실패하더라도 다른 모든 명령들이 실행된다.
    - 왜 Redis 의 트랜잭션은 롤백을 지원하지 않는가?
        - RDB 관점에서 생각해보면 레디스의 트랜잭션 처리 중 일부 명령어가 실패했는데 롤백하지 않는 점이 이상할 수 있다.
        - 사실 이 방식이 장점이라고 생각하는 발상의 전환
        - Redis 명령은 잘못된 구문으로 호출된 경우 혹은 잘못된 데이터 유형에 대한 요청이 실패하는 상황이 발생한다.
        - 즉, 실패한 명령은 프로그래밍 오류의 결과 -> 대부분 개발 단계에서 발견할 수 있다.
        - 그래서 레디스는 롤백할 필요가 없기 때문에 내부적으로 단순화되고 빨라졌다.
    - Redis 에서 일관성을 어떻게 보장하는가?
        - 레디스는 데이터 동기화를 위해 두가지 방법을 제공한다.
        - 데이터의 저장 결과를 클라이언트로 응답하기 전에 모든 노드에 데이터를 저장하는 동기식 방법
            - 모든 노드의 데이터 저장이 완료되는 시간 동안 클라이언트에게 저장 결과를 돌려줄 수 없으므로 느린 응답시간을 가짐
            - 하지만, 강한 데이터의 정합성을 보장함
        - 메모리나 임시 파일에 기록하고 클라이언트에 먼저 응답한 다음, 특정 이벤트 또는 프로세스를 사용하여 노드로 데이터를 동기화하는 비동기식 방법
            - 빠른 응답을 줄 수 있지만, 쓰기 노드에 장애가 발생하였을 때 데이터를 잃어버릴 수 있다는 단점이 있다.