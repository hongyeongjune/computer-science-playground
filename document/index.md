## Index
* 대용량 데이터에서 원하는 데이터를 빠르게 조회하기 위해 사용하는 기술 -> select 쿼리의 조회 속도를 향상시키기는 것이 목적
* 즉, 삽입, 삭제, 수정 시 성능이 그렇게 좋지 않다.
* Index 작성
    - Index 도 하나의 데이터베이스 객체이다.
    - Oracle, DB2 등에서는 스키마 객체
    - MySQL, SQL Server 등에서는 테이블 내의 객체
    - 즉, Index 도 저장공간이 필요하고 대략 데이터의 10% 정도의 용량이 필요하다.
* Index 검색 알고리즘
    - Full Table Scan : Index 가 적용이 안되어있어서 처음부터 하나하나 다 조회한다.
    - B-Tree : Index 에서 가장 흔하게 사용하는 자료구조
* 인덱스 구조 및 특성
    - 인덱스와 실제 데이터가 저장된 데이터는 따로 관리된다.
    - 즉, B-Tree 구조이기 때문에 리프노드가 항상 실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있다.
* 인덱스 사용 시 주의 사항
    - Insert
        - Index 는 정렬이 된 상태로 데이터가 저장이 되어야하기 때문에 삽입과정이 느리다.
        - Index 는 테이블과 별도의 객체라서 각각 삽입해야한다.
        - 과정
            - B-Tree 상 적절한 위치 검색
            - 저장될 위치 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree 의 리프 노드에 저장
            - 만약 리프 노드가 꽉 차서 더 저장할 수 없을 때 리프 노드가 분리 되는데 이는 처리 범위가 브랜치 노드까지 넓어진다.
    - Delete
        - 실제 테이블에선 삭제되지만, 인덱스 테이블에서는 사용안함이라고 표시하기 때문에 메모리 낭비가 발생
    - Update
        - Index 에는 Update 라는 개념이 없어서 테이블에 update 가 되면 인덱스는 delete 가 되고 insert 가 된다.
* 인덱스 조회 시 방법
    - Index Range Scan
        - 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
        - 루트노드부터 비교를 시작해 리프노드에 도달하여 시작지점을 찾고 그 후 리프노드의 레코드를 순서대로 조회한다. (리프 노드끼리 연결되어있어서 가능)
        - 이 때, 리프 노드에 저장된 레코드 주소로 데이터파일의 레코드를 읽는데 레코드 한건 한건 단위로 랜덤 I/O 가 발생한다.
        - 보편적으로, 레코드가 20% ~ 25%를 넘으면 테이블 풀 스캔이 더 좋다고 한다.
    - Index Full Scan
        - 인덱스의 처음부터 끝까지 모두 읽는 방식
        - 인덱스 선두 컬럼이 조건절에 없으면 옵티마이저는 우선 테이블 풀 스캔을 고려한다.
        - 그런데 대용량 테이블의 경우 테이블 풀 스캔의 부담이 크다면 옵티마이저는 인덱스 풀 스캔을 고려한다.
        - 인덱스가 차지하는 면적은 테이블이 차지하는 면적보다 훨씬 적다.
        - 인덱스 스캔 단계에서 대부분 레코드를 필터링하고 아주 일부만 테이블 액세스할 수 있다면, 테이블 풀 스캔보다 인덱스 풀 스캔이 유리하다.
        - 그래서 옵티마이저는 이런 상황에서 Index Full Scan 방식을 선택한다.
        - 즉, 동자 방식은 인덱스 선두 컬럼이 조건절에 없으면 맨 처음 리프 노드로 가서 리프노드 끼리 연결되어 있으니 리프 노드를 탐색하면서 필요한 일부 데이터만 테이블 엑세스가 발생하도록 한다.
* Single Block I/O
    - 인덱스 레인지 스캔, 인덱스 풀 스캔 시 사용한다.
    - 한번에 한블록씩 요청해서 메모리에 적재하는 방식
* Multi Block I/O
    - 테이블 풀 스캔, 인덱스 패스트 풀 스캔 시 사용한다.
    - 한번에 여러블록씩 요청해서 메모리에 적재하는 방식
* Index Full Scan vs Table Full Scan
    - 멀티 블락 I/O 의 유무에 따라 다르다.
    - Full Table Scan 은 Multi-Block Read 가 가능하지만 Index Full Scan 은 리프블록을 일일히 방문하기 때문에 Single Block Read 밖에 할 수 없다.
    - 즉, 때로는 Full Table Scan 의 성능이 더 좋을 때가 있다.
* Index Full Scan vs Index Fast Full Scan
    - Index Full Scan 은 논리적 순서로 싱글 블락 I/O 방식이다.
    - Index Fast Full Scan 은 정렬된 상태를 보장하지 않고 물리적 순서를 가져와 멀티 블락 I/O 방식으로 동작한다.
* 인덱스 설정 기준
    - Cardinality 가 높은 것을 인덱스 칼럼으로 설정해야한다.
        - 중복도가 낮으면 확실하게 데이터를 찾을 수 있는데, 높으면 찾고나서 다시 찾고 또 찾아야한다.
        - Cardinality
          - 중복도가 낮으면 높다고 표현하고 중복도가 낮으면 높다고 표현한다.
    - 조건절에 자주 등장하는 칼럼
* Clustered Index vs Non-Clustered Index
    - Clustered Index
        - 테이블의 데이터를 지정된 컬럼에 대해 물리적으로 재배열 -> 삽입, 삭제, 수정 시 테이블의 데이터를 정렬 시킨다.
        - 테이블 당 한개만 존재
        - 테이블에서 가장 효율적일 것 같은 컬럼을 Clustered Index 로 지정해야된다.
        - 인덱스에 데이터가 포함되어 있다.
        - 이미 많은 데이터가 저장된 상태에서 Clustered Index 를 추가하면 많은 데이터를 정렬해야돼서 많은 자원을 사용한다.
        - 동작 방식
            - Index 순으로 테이블이 정렬됨
            - 그 후 Root Page 와 Leaf Page 로 이루어진 Index Page 로 구성됨
            - Root Page 는 Index Key 와 Leaf Page 의 번호를 가지고 있고, Index Key 에 따라 탐색해야할 Leaf Page 를 매핑하는 역할을 함
    - Non-Clustered Index
        - 테이블의 데이터를 지정된 컬럼에 대해 물리적으로 재배열을 하지 않는다. -> 삽입, 삭제, 수정 시 성능이 Clustered 보다 좋다.
        - 단지 지정된 컬럼에 대해 정렬시킨 인덱스를 만든다.
        - 테이블 당 여러개 존재 가능
        - 동작 방식
            - 기존의 테이블을 건들지 않고 Root Page 와 Leaf page 로 이루어진 별도의 Index Page 생성
            - 그리고 Leaf Page 에는 데이터가 담기지 않고, 기존 데이터 테이블에 있는 데이터의 위치를 가리키는 포인터를 저장
            - 즉, Root Page 는 Index key 와 Leaf Page 의 번호를 가지고 있고, Leaf Page 는 Index 와 실제 데이터의 위치를 가리키는 포인터를 갖도록 구성
* Index 가 주로 B-Tree 를 사용하는 이유
    - HashTable or HashMap
        - HashTable 또는 HashMap 은 검색속도가 O(1) 로 가장 빠르다.
        - 그러나, 데이터베이스는 등호 연산 뿐 아니라 부등호 연산도 수행한다.
        - 즉, 특정 값 보다 크거나 작은 값을 찾으려면 O(1)의 시간 복잡도를 보장할 수 없다.
    - Red-Black Tree
        - 비트리와 마찬가지로 이진 균형트리이다.
        - 각 노드마다 하나의 데이터를 가진다.
        - 비트리는 브랜치 노드의 여러개의 데이터를 가질 수 있기 때문에 자식에 접근하는 횟수가 훨씬 적다.
* 디스크 읽기 방식
    - 데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건인 것들이 상당히 많다.
    - 대부분의 저장 매체는 디스크 드라이브의 플래터(Platter, 디스크 드라이브 내부의 데이터 저장용 원판)를 회전시켜서 데이터를 읽고 쓰는 기계적인 방식을 사용한다.
    - 그리고 이런 디스크 드라이브를 하드 디스크 드라이버(HDD)라고도 부르기도 한다.
* SSD
    - SSD 는 기존의 디스크 드라이브에서 데이터 저장용 플래터를 제거하고 대신 플래시 메모리를 장착하였다.
    - 플래시 메모리를 장착하므로써 원판을 기계적으로 회전시킬 필요가 없어 속도가 굉장히 빠르다.
    - 플래시 메모리는 비휘발성 메모리이다.
    - 왜 SSD 는 HDD 보다 빠른가?
        - 이는 플래터로 원판을 돌려가며 물리적으로 데이터를 읽는 태생적 한계 때문이다.
        - 원판의 물리적 거리만큼 시간이 걸릴 수 밖에 없는 HDD 의 input 방식(데이터의 지점차이가 발생)은 플래시메모리를 써서 물리적제약이 없어 데이터의 지점차이가 없이 똑같이 접근하는 SSD 를 이길 수 없다.
    - 디스크 헤더를 움직이지 않고 한번에 많은 데이터를 읽는 순차 I/O 는 SSD 와 HDD 큰 차이가 없다.
    - 하지만 랜덤 I/O 는 SSD 가 훨씬 빠르다.
* 랜덤 I/O vs 순차 I/O
    - 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미
    - HDD 의 경우 랜덤 I/O 가 훨씬 안좋다.
    - 즉, 디스크의 성능은 디스크 헤드 위치 이동 없이 얼마나 많은 데이터를 기록하는지가 중요하다.
    - 일반적으로 쿼리 튜닝은 랜덤 I/O 를 줄이는 것이 관건
    - 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미한다.
    - 인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 I/O를 사용하며, 풀 테이블 스캔은 순차 I/O를 사용한다.